{"meta":{"title":"iamsimate","subtitle":"司马特的博客","description":"","author":"HE JIAYI","url":"http://iamsimate.github.io","root":"/"},"pages":[{"title":"about","date":"2022-07-30T10:40:40.000Z","updated":"2022-09-08T05:34:37.108Z","comments":true,"path":"about/index.html","permalink":"http://iamsimate.github.io/about/index.html","excerpt":"","text":"小怡子的自我介绍 basic informaition 这是来自HUST数学学院的准大四学生，专业是信息与计算科学，努力学习coding和有限元分析中，平常最爱化妆买衣服，唱歌吃东西，宅家看小说~ course taken - 数学专业课 数学分析、高等代数、常微分方程、复变函数、实变函数、近世代数、概率论、离散数学、偏微分方程、数理统计、数值逼近、数值代数、随机过程、偏微分方程数值解、微分几何、信息论基础、控制论 - 经济必修课 会计学、经济学原理、政治经济学原理 - 其他 C++、计算机网络技术及应用 coding language vb，c++，python，mysql，matlab，java research project PML for optical modes in dielectric cavities Target：to solve the EPs problem by using numerical method or applying perturbation theory, or by machine learning. Still working on it. future plan Try my best to pursue a phd degree and by the way, learn more about coding and Cantonese."},{"title":"书单","date":"2022-10-03T09:50:51.470Z","updated":"2022-10-03T04:46:31.551Z","comments":false,"path":"books/index.html","permalink":"http://iamsimate.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-14T17:13:24.000Z","updated":"2022-07-15T06:29:24.485Z","comments":true,"path":"categories/index.html","permalink":"http://iamsimate.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-03T05:50:34.115Z","updated":"2022-10-03T04:46:31.551Z","comments":true,"path":"links/index.html","permalink":"http://iamsimate.github.io/links/index.html","excerpt":"","text":""},{"title":"PDF阅读","date":"2022-03-03T08:40:27.000Z","updated":"2022-10-03T09:47:57.301Z","comments":true,"path":"pdf/index.html","permalink":"http://iamsimate.github.io/pdf/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-03T04:46:31.551Z","updated":"2022-10-03T04:46:31.551Z","comments":false,"path":"repository/index.html","permalink":"http://iamsimate.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-14T17:46:03.000Z","updated":"2022-07-15T06:29:26.929Z","comments":true,"path":"tags/index.html","permalink":"http://iamsimate.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"heart/-3D-main/-3D-main/README","date":"2022-12-04T09:30:08.487Z","updated":"2022-11-11T13:17:56.000Z","comments":true,"path":"2022/12/04/heart/-3D-main/-3D-main/README/","link":"","permalink":"http://iamsimate.github.io/2022/12/04/heart/-3D-main/-3D-main/README/","excerpt":"","text":"-3D 李峋爱心跳动-3D github直接下载需要在index.HTML中修改引入js文件的路径 电视剧点燃我，温暖你 打火机与公主裙 李洵爱心跳动效果 demo","categories":[],"tags":[]},{"title":"heart","slug":"heart/index","date":"2022-11-17T13:09:13.000Z","updated":"2022-12-04T09:37:36.586Z","comments":true,"path":"2022/11/17/heart/index/","link":"","permalink":"http://iamsimate.github.io/2022/11/17/heart/index/","excerpt":"","text":"爱心跳动,3D拖拽搬 爱心跳动,抖音ID:不吃蟹黄 作品参考bootstrapmb,引入three基于canvas制作 (function () { const _face = new THREE.Triangle(); const _color = new THREE.Vector3(); class MeshSurfaceSampler { constructor(mesh) { let geometry = mesh.geometry; if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) { throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.'); } if (geometry.index) { console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.'); geometry = geometry.toNonIndexed(); } this.geometry = geometry; this.randomFunction = Math.random; this.positionAttribute = this.geometry.getAttribute('position'); this.colorAttribute = this.geometry.getAttribute('color'); this.weightAttribute = null; this.distribution = null; } setWeightAttribute(name) { this.weightAttribute = name ? this.geometry.getAttribute(name) : null; return this; } build() { const positionAttribute = this.positionAttribute; const weightAttribute = this.weightAttribute; const faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face. for (let i = 0; i < positionAttribute.count; i += 3) { let faceWeight = 1; if (weightAttribute) { faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2); } _face.a.fromBufferAttribute(positionAttribute, i); _face.b.fromBufferAttribute(positionAttribute, i + 1); _face.c.fromBufferAttribute(positionAttribute, i + 2); faceWeight *= _face.getArea(); faceWeights[i / 3] = faceWeight; } // Store cumulative total face weights in an array, where weight index // corresponds to face index. this.distribution = new Float32Array(positionAttribute.count / 3); let cumulativeTotal = 0; for (let i = 0; i < faceWeights.length; i++) { cumulativeTotal += faceWeights[i]; this.distribution[i] = cumulativeTotal; } return this; } setRandomGenerator(randomFunction) { this.randomFunction = randomFunction; return this; } sample(targetPosition, targetNormal, targetColor) { const cumulativeTotal = this.distribution[this.distribution.length - 1]; const faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal); return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor); } binarySearch(x) { const dist = this.distribution; let start = 0; let end = dist.length - 1; let index = - 1; while (start 0) { return this.materials[this.materials.length - 1]; } return undefined; }, _finalize: function (end) { const lastMultiMaterial = this.currentMaterial(); if (lastMultiMaterial && lastMultiMaterial.groupEnd === - 1) { lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3; lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart; lastMultiMaterial.inherited = false; } // Ignore objects tail materials if no face declarations followed them before a new o/g started. if (end && this.materials.length > 1) { for (let mi = this.materials.length - 1; mi >= 0; mi--) { if (this.materials[mi].groupCount = 0 ? index - 1 : index + len / 3) * 3; }, parseNormalIndex: function (value, len) { const index = parseInt(value, 10); return (index >= 0 ? index - 1 : index + len / 3) * 3; }, parseUVIndex: function (value, len) { const index = parseInt(value, 10); return (index >= 0 ? index - 1 : index + len / 2) * 2; }, addVertex: function (a, b, c) { const src = this.vertices; const dst = this.object.geometry.vertices; dst.push(src[a + 0], src[a + 1], src[a + 2]); dst.push(src[b + 0], src[b + 1], src[b + 2]); dst.push(src[c + 0], src[c + 1], src[c + 2]); }, addVertexPoint: function (a) { const src = this.vertices; const dst = this.object.geometry.vertices; dst.push(src[a + 0], src[a + 1], src[a + 2]); }, addVertexLine: function (a) { const src = this.vertices; const dst = this.object.geometry.vertices; dst.push(src[a + 0], src[a + 1], src[a + 2]); }, addNormal: function (a, b, c) { const src = this.normals; const dst = this.object.geometry.normals; dst.push(src[a + 0], src[a + 1], src[a + 2]); dst.push(src[b + 0], src[b + 1], src[b + 2]); dst.push(src[c + 0], src[c + 1], src[c + 2]); }, addFaceNormal: function (a, b, c) { const src = this.vertices; const dst = this.object.geometry.normals; _vA.fromArray(src, a); _vB.fromArray(src, b); _vC.fromArray(src, c); _cb.subVectors(_vC, _vB); _ab.subVectors(_vA, _vB); _cb.cross(_ab); _cb.normalize(); dst.push(_cb.x, _cb.y, _cb.z); dst.push(_cb.x, _cb.y, _cb.z); dst.push(_cb.x, _cb.y, _cb.z); }, addColor: function (a, b, c) { const src = this.colors; const dst = this.object.geometry.colors; if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]); if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]); if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]); }, addUV: function (a, b, c) { const src = this.uvs; const dst = this.object.geometry.uvs; dst.push(src[a + 0], src[a + 1]); dst.push(src[b + 0], src[b + 1]); dst.push(src[c + 0], src[c + 1]); }, addDefaultUV: function () { const dst = this.object.geometry.uvs; dst.push(0, 0); dst.push(0, 0); dst.push(0, 0); }, addUVLine: function (a) { const src = this.uvs; const dst = this.object.geometry.uvs; dst.push(src[a + 0], src[a + 1]); }, addFace: function (a, b, c, ua, ub, uc, na, nb, nc) { const vLen = this.vertices.length; let ia = this.parseVertexIndex(a, vLen); let ib = this.parseVertexIndex(b, vLen); let ic = this.parseVertexIndex(c, vLen); this.addVertex(ia, ib, ic); this.addColor(ia, ib, ic); // normals if (na !== undefined && na !== '') { const nLen = this.normals.length; ia = this.parseNormalIndex(na, nLen); ib = this.parseNormalIndex(nb, nLen); ic = this.parseNormalIndex(nc, nLen); this.addNormal(ia, ib, ic); } else { this.addFaceNormal(ia, ib, ic); } // uvs if (ua !== undefined && ua !== '') { const uvLen = this.uvs.length; ia = this.parseUVIndex(ua, uvLen); ib = this.parseUVIndex(ub, uvLen); ic = this.parseUVIndex(uc, uvLen); this.addUV(ia, ib, ic); this.object.geometry.hasUVIndices = true; } else { // add placeholder values (for inconsistent face definitions) this.addDefaultUV(); } }, addPointGeometry: function (vertices) { this.object.geometry.type = 'Points'; const vLen = this.vertices.length; for (let vi = 0, l = vertices.length; vi < l; vi++) { const index = this.parseVertexIndex(vertices[vi], vLen); this.addVertexPoint(index); this.addColor(index); } }, addLineGeometry: function (vertices, uvs) { this.object.geometry.type = 'Line'; const vLen = this.vertices.length; const uvLen = this.uvs.length; for (let vi = 0, l = vertices.length; vi < l; vi++) { this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen)); } for (let uvi = 0, l = uvs.length; uvi < l; uvi++) { this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen)); } } }; state.startObject('', false); return state; } // class OBJLoader extends THREE.Loader { constructor(manager) { super(manager); this.materials = null; } load(url, onLoad, onProgress, onError) { const scope = this; const loader = new THREE.FileLoader(this.manager); loader.setPath(this.path); loader.setRequestHeader(this.requestHeader); loader.setWithCredentials(this.withCredentials); loader.load(url, function (text) { try { onLoad(scope.parse(text)); } catch (e) { if (onError) { onError(e); } else { console.error(e); } scope.manager.itemError(url); } }, onProgress, onError); } setMaterials(materials) { this.materials = materials; return this; } parse(text) { const state = new ParserState(); if (text.indexOf('\\r\\n') !== - 1) { // This is faster than String.split with regex that splits on both text = text.replace(/\\r\\n/g, '\\n'); } if (text.indexOf('\\\\\\n') !== - 1) { // join lines separated by a line continuation character (\\) text = text.replace(/\\\\\\n/g, ''); } const lines = text.split('\\n'); let line = '', lineFirstChar = ''; let lineLength = 0; let result = []; // Faster to just trim left side of the line. Use if available. const trimLeft = typeof ''.trimLeft === 'function'; for (let i = 0, l = lines.length; i < l; i++) { line = lines[i]; line = trimLeft ? line.trimLeft() : line.trim(); lineLength = line.length; if (lineLength === 0) continue; lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any if (lineFirstChar === '#') continue; if (lineFirstChar === 'v') { const data = line.split(/\\s+/); switch (data[0]) { case 'v': state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3])); if (data.length >= 7) { state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6])); } else { // if no colors are defined, add placeholders so color and vertex indices match state.colors.push(undefined, undefined, undefined); } break; case 'vn': state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3])); break; case 'vt': state.uvs.push(parseFloat(data[1]), parseFloat(data[2])); break; } } else if (lineFirstChar === 'f') { const lineData = line.substr(1).trim(); const vertexData = lineData.split(/\\s+/); const faceVertices = []; // Parse the face vertex data into an easy to work with format for (let j = 0, jl = vertexData.length; j < jl; j++) { const vertex = vertexData[j]; if (vertex.length > 0) { const vertexParts = vertex.split('/'); faceVertices.push(vertexParts); } } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon const v1 = faceVertices[0]; for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) { const v2 = faceVertices[j]; const v3 = faceVertices[j + 1]; state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]); } } else if (lineFirstChar === 'l') { const lineParts = line.substring(1).trim().split(' '); let lineVertices = []; const lineUVs = []; if (line.indexOf('/') === - 1) { lineVertices = lineParts; } else { for (let li = 0, llen = lineParts.length; li < llen; li++) { const parts = lineParts[li].split('/'); if (parts[0] !== '') lineVertices.push(parts[0]); if (parts[1] !== '') lineUVs.push(parts[1]); } } state.addLineGeometry(lineVertices, lineUVs); } else if (lineFirstChar === 'p') { const lineData = line.substr(1).trim(); const pointData = lineData.split(' '); state.addPointGeometry(pointData); } else if ((result = _object_pattern.exec(line)) !== null) { // o object_name // or // g group_name // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869 // let name = result[ 0 ].substr( 1 ).trim(); const name = (' ' + result[0].substr(1).trim()).substr(1); state.startObject(name); } else if (_material_use_pattern.test(line)) { // material state.object.startMaterial(line.substring(7).trim(), state.materialLibraries); } else if (_material_library_pattern.test(line)) { // mtl file state.materialLibraries.push(line.substring(7).trim()); } else if (_map_use_pattern.test(line)) { // the line is parsed but ignored since the loader assumes textures are defined MTL files // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method) console.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.'); } else if (lineFirstChar === 's') { result = line.split(' '); // smooth shading // @todo Handle files that have varying smooth values for a set of faces inside one geometry, // but does not define a usemtl for each face set. // This should be detected and a dummy material created (later MultiMaterial and geometry groups). // This requires some care to not create extra material on each smooth value for \"normal\" obj files. // where explicit usemtl defines geometry groups. // Example asset: examples/models/obj/cerberus/Cerberus.obj /* * http://paulbourke.net/dataformats/obj/ * or * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf * * From chapter \"Grouping\" Syntax explanation \"s group_number\": * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off. * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form * surfaces, smoothing groups are either turned on or off; there is no difference between values greater * than 0.\" */ if (result.length > 1) { const value = result[1].trim().toLowerCase(); state.object.smooth = value !== '0' && value !== 'off'; } else { // ZBrush can produce \"s\" lines #11707 state.object.smooth = true; } const material = state.object.currentMaterial(); if (material) material.smooth = state.object.smooth; } else { // Handle null terminated files without exception if (line === '\\0') continue; console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"'); } } state.finalize(); const container = new THREE.Group(); container.materialLibraries = [].concat(state.materialLibraries); const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0); if (hasPrimitives === true) { for (let i = 0, l = state.objects.length; i < l; i++) { const object = state.objects[i]; const geometry = object.geometry; const materials = object.materials; const isLine = geometry.type === 'Line'; const isPoints = geometry.type === 'Points'; let hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces if (geometry.vertices.length === 0) continue; const buffergeometry = new THREE.BufferGeometry(); buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3)); if (geometry.normals.length > 0) { buffergeometry.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3)); } if (geometry.colors.length > 0) { hasVertexColors = true; buffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3)); } if (geometry.hasUVIndices === true) { buffergeometry.setAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2)); } // Create materials const createdMaterials = []; for (let mi = 0, miLen = materials.length; mi < miLen; mi++) { const sourceMaterial = materials[mi]; const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors; let material = state.materials[materialHash]; if (this.materials !== null) { material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material. if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) { const materialLine = new THREE.LineBasicMaterial(); THREE.Material.prototype.copy.call(materialLine, material); materialLine.color.copy(material.color); material = materialLine; } else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) { const materialPoints = new THREE.PointsMaterial({ size: 10, sizeAttenuation: false }); THREE.Material.prototype.copy.call(materialPoints, material); materialPoints.color.copy(material.color); materialPoints.map = material.map; material = materialPoints; } } if (material === undefined) { if (isLine) { material = new THREE.LineBasicMaterial(); } else if (isPoints) { material = new THREE.PointsMaterial({ size: 1, sizeAttenuation: false }); } else { material = new THREE.MeshPhongMaterial(); } material.name = sourceMaterial.name; material.flatShading = sourceMaterial.smooth ? false : true; material.vertexColors = hasVertexColors; state.materials[materialHash] = material; } createdMaterials.push(material); } // Create mesh let mesh; if (createdMaterials.length > 1) { for (let mi = 0, miLen = materials.length; mi < miLen; mi++) { const sourceMaterial = materials[mi]; buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi); } if (isLine) { mesh = new THREE.LineSegments(buffergeometry, createdMaterials); } else if (isPoints) { mesh = new THREE.Points(buffergeometry, createdMaterials); } else { mesh = new THREE.Mesh(buffergeometry, createdMaterials); } } else { if (isLine) { mesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]); } else if (isPoints) { mesh = new THREE.Points(buffergeometry, createdMaterials[0]); } else { mesh = new THREE.Mesh(buffergeometry, createdMaterials[0]); } } mesh.name = object.name; container.add(mesh); } } else { // if there is only the default parser state object with no geometry data, interpret data as point cloud if (state.vertices.length > 0) { const material = new THREE.PointsMaterial({ size: 1, sizeAttenuation: false }); const buffergeometry = new THREE.BufferGeometry(); buffergeometry.setAttribute('position', new THREE.Float32BufferAttribute(state.vertices, 3)); if (state.colors.length > 0 && state.colors[0] !== undefined) { buffergeometry.setAttribute('color', new THREE.Float32BufferAttribute(state.colors, 3)); material.vertexColors = true; } const points = new THREE.Points(buffergeometry, material); container.add(points); } } return container; } } THREE.OBJLoader = OBJLoader; })();","categories":[{"name":"技术","slug":"技术","permalink":"http://iamsimate.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"self introduction by Xu Hui","slug":"self introduction by Xu Hui","date":"2022-11-11T10:04:51.000Z","updated":"2022-11-11T03:42:14.392Z","comments":true,"path":"2022/11/11/self introduction by Xu Hui/","link":"","permalink":"http://iamsimate.github.io/2022/11/11/self%20introduction%20by%20Xu%20Hui/","excerpt":"","text":"","categories":[{"name":"阅读","slug":"阅读","permalink":"http://iamsimate.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"偏微分方程","slug":"偏微分方程","date":"2022-10-16T06:21:37.000Z","updated":"2022-10-16T06:24:05.098Z","comments":true,"path":"2022/10/16/偏微分方程/","link":"","permalink":"http://iamsimate.github.io/2022/10/16/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"阅读","slug":"阅读","permalink":"http://iamsimate.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"泛函分析","slug":"泛函分析","date":"2022-07-14T10:04:51.000Z","updated":"2022-10-03T08:33:23.039Z","comments":true,"path":"2022/07/14/泛函分析/","link":"","permalink":"http://iamsimate.github.io/2022/07/14/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"阅读","slug":"阅读","permalink":"http://iamsimate.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"我的第一篇文章","slug":"我的第一篇文章","date":"2022-07-14T10:04:51.000Z","updated":"2022-11-17T10:42:03.715Z","comments":true,"path":"2022/07/14/我的第一篇文章/","link":"","permalink":"http://iamsimate.github.io/2022/07/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"前言 大家好，今后将开始我的新学习之路，花费两天时间终于解决了基本问题，搭建好了简陋的博客，之后会将学习笔记陆续搬到网站上，公众号也会同步更新。 如何制作博客以及将博客部署到github上 我基本上是在csdn上找的教程，其中一些文件的代码修改我并不太懂，回忆搭建过程也是坎坷零星，如果后面有时间，把我搭建过程中遇到的问题整理整理。以下是参考链接（全在我的主页收藏夹里了）: https://blog.csdn.net/m0_46488303?type=collect &lt;code data-type=&quot;pre-exercise-code&quot;&gt; # 这部分代码是在初始化的时候自动运行的 b = 6 &lt;/code&gt; &lt;code data-type=&quot;sample-code&quot;&gt; # 这里是示例代码 # Print out a &lt;/code&gt; &lt;code data-type=&quot;solution&quot;&gt; # 这里是答案 a &lt;- 5 # Print out a print(a) &lt;/code&gt; &lt;code data-type=&quot;sct&quot;&gt; test_object(&quot;a&quot;) test_function(&quot;print&quot;) success_msg(&quot;Great job!&quot;) &lt;/code&gt; &lt;div data-type=&quot;hint&quot;&gt;Use the assignment operator (code&lt;-&lt;/code&gt;) to create the variable codea&lt;/code&gt;.&lt;/div&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://iamsimate.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://iamsimate.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"阅读","slug":"阅读","permalink":"http://iamsimate.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]}