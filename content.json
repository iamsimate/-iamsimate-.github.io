{"meta":{"title":"iamsimate","subtitle":"司马特的博客","description":"","author":"HE JIAYI","url":"http://iamsimate.github.io","root":"/"},"pages":[{"title":"about","date":"2022-07-30T10:40:40.000Z","updated":"2022-09-08T05:34:37.108Z","comments":true,"path":"about/index.html","permalink":"http://iamsimate.github.io/about/index.html","excerpt":"","text":"小怡子的自我介绍 basic informaition 这是来自HUST数学学院的准大四学生，专业是信息与计算科学，努力学习coding和有限元分析中，平常最爱化妆买衣服，唱歌吃东西，宅家看小说~ course taken - 数学专业课 数学分析、高等代数、常微分方程、复变函数、实变函数、近世代数、概率论、离散数学、偏微分方程、数理统计、数值逼近、数值代数、随机过程、偏微分方程数值解、微分几何、信息论基础、控制论 - 经济必修课 会计学、经济学原理、政治经济学原理 - 其他 C++、计算机网络技术及应用 coding language vb，c++，python，mysql，matlab，java research project PML for optical modes in dielectric cavities Target：to solve the EPs problem by using numerical method or applying perturbation theory, or by machine learning. Still working on it. future plan Try my best to pursue a phd degree and by the way, learn more about coding and Cantonese."},{"title":"书单","date":"2022-10-03T09:50:51.470Z","updated":"2022-10-03T04:46:31.551Z","comments":false,"path":"books/index.html","permalink":"http://iamsimate.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-07-14T17:13:24.000Z","updated":"2022-07-15T06:29:24.485Z","comments":true,"path":"categories/index.html","permalink":"http://iamsimate.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-03T05:50:34.115Z","updated":"2022-10-03T04:46:31.551Z","comments":true,"path":"links/index.html","permalink":"http://iamsimate.github.io/links/index.html","excerpt":"","text":""},{"title":"PDF阅读","date":"2022-03-03T08:40:27.000Z","updated":"2022-10-03T09:47:57.301Z","comments":true,"path":"pdf/index.html","permalink":"http://iamsimate.github.io/pdf/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-03T04:46:31.551Z","updated":"2022-10-03T04:46:31.551Z","comments":false,"path":"repository/index.html","permalink":"http://iamsimate.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-14T17:46:03.000Z","updated":"2022-07-15T06:29:26.929Z","comments":true,"path":"tags/index.html","permalink":"http://iamsimate.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-11-17T10:30:21.625Z","updated":"2022-11-17T10:29:09.987Z","comments":true,"path":"html/爱心.html","permalink":"http://iamsimate.github.io/html/%E7%88%B1%E5%BF%83.html","excerpt":"","text":"* { padding: 0; margin: 0; } html, body { height: 100%; padding: 0; margin: 0; background: #000; } .aa { position: fixed; left: 50%; bottom: 10px; color: #ccc; } .container { width: 100%; height: 100%; } canvas { z-index: 99; position: absolute; width: 100%; height: 100%; } /* * Settings */ var settings = { particles: { length: 500, // maximum amount of particles duration: 2, // particle duration in sec velocity: 100, // particle velocity in pixels/sec effect: -0.75, // play with this for a nice effect size: 30, // particle size in pixels }, }; (function () { var b = 0; var c = [\"ms\", \"moz\", \"webkit\", \"o\"]; for (var a = 0; a < c.length && !window.requestAnimationFrame; ++a) { window.requestAnimationFrame = window[c[a] + \"RequestAnimationFrame\"]; window.cancelAnimationFrame = window[c[a] + \"CancelAnimationFrame\"] || window[c[a] + \"CancelRequestAnimationFrame\"]; } if (!window.requestAnimationFrame) { window.requestAnimationFrame = function (h, e) { var d = new Date().getTime(); var f = Math.max(0, 16 - (d - b)); var g = window.setTimeout(function () { h(d + f); }, f); b = d + f; return g; }; } if (!window.cancelAnimationFrame) { window.cancelAnimationFrame = function (d) { clearTimeout(d); }; } })(); /* * Point class */ var Point = (function () { function Point(x, y) { this.x = typeof x !== \"undefined\" ? x : 0; this.y = typeof y !== \"undefined\" ? y : 0; } Point.prototype.clone = function () { return new Point(this.x, this.y); }; Point.prototype.length = function (length) { if (typeof length == \"undefined\") return Math.sqrt(this.x * this.x + this.y * this.y); this.normalize(); this.x *= length; this.y *= length; return this; }; Point.prototype.normalize = function () { var length = this.length(); this.x /= length; this.y /= length; return this; }; return Point; })(); /* * Particle class */ var Particle = (function () { function Particle() { this.position = new Point(); this.velocity = new Point(); this.acceleration = new Point(); this.age = 0; } Particle.prototype.initialize = function (x, y, dx, dy) { this.position.x = x; this.position.y = y; this.velocity.x = dx; this.velocity.y = dy; this.acceleration.x = dx * settings.particles.effect; this.acceleration.y = dy * settings.particles.effect; this.age = 0; }; Particle.prototype.update = function (deltaTime) { this.position.x += this.velocity.x * deltaTime; this.position.y += this.velocity.y * deltaTime; this.velocity.x += this.acceleration.x * deltaTime; this.velocity.y += this.acceleration.y * deltaTime; this.age += deltaTime; }; Particle.prototype.draw = function (context, image) { function ease(t) { return --t * t * t + 1; } var size = image.width * ease(this.age / settings.particles.duration); context.globalAlpha = 1 - this.age / settings.particles.duration; context.drawImage( image, this.position.x - size / 2, this.position.y - size / 2, size, size ); }; return Particle; })(); /* * ParticlePool class */ var ParticlePool = (function () { var particles, firstActive = 0, firstFree = 0, duration = settings.particles.duration; function ParticlePool(length) { // create and populate particle pool particles = new Array(length); for (var i = 0; i < particles.length; i++) particles[i] = new Particle(); } ParticlePool.prototype.add = function (x, y, dx, dy) { particles[firstFree].initialize(x, y, dx, dy); // handle circular queue firstFree++; if (firstFree == particles.length) firstFree = 0; if (firstActive == firstFree) firstActive++; if (firstActive == particles.length) firstActive = 0; }; ParticlePool.prototype.update = function (deltaTime) { var i; // update active particles if (firstActive < firstFree) { for (i = firstActive; i < firstFree; i++) particles[i].update(deltaTime); } if (firstFree < firstActive) { for (i = firstActive; i < particles.length; i++) particles[i].update(deltaTime); for (i = 0; i < firstFree; i++) particles[i].update(deltaTime); } // remove inactive particles while ( particles[firstActive].age >= duration && firstActive != firstFree ) { firstActive++; if (firstActive == particles.length) firstActive = 0; } }; ParticlePool.prototype.draw = function (context, image) { // draw active particles if (firstActive < firstFree) { for (i = firstActive; i < firstFree; i++) particles[i].draw(context, image); } if (firstFree < firstActive) { for (i = firstActive; i < particles.length; i++) particles[i].draw(context, image); for (i = 0; i < firstFree; i++) particles[i].draw(context, image); } }; return ParticlePool; })(); /* * Putting it all together */ (function (canvas) { var context = canvas.getContext(\"2d\"), particles = new ParticlePool(settings.particles.length), particleRate = settings.particles.length / settings.particles.duration, // particles/sec time; // get point on heart with -PI"},{"title":"","date":"2022-11-17T10:32:11.455Z","updated":"2022-11-17T10:32:11.455Z","comments":true,"path":"html/js/爱心.js","permalink":"http://iamsimate.github.io/html/js/%E7%88%B1%E5%BF%83.js","excerpt":"","text":"* { padding: 0; margin: 0; } html, body { height: 100%; padding: 0; margin: 0; background: #000; } .aa { position: fixed; left: 50%; bottom: 10px; color: #ccc; } .container { width: 100%; height: 100%; } canvas { z-index: 99; position: absolute; width: 100%; height: 100%; } /* * Settings */ var settings = { particles: { length: 500, // maximum amount of particles duration: 2, // particle duration in sec velocity: 100, // particle velocity in pixels/sec effect: -0.75, // play with this for a nice effect size: 30, // particle size in pixels }, }; (function () { var b = 0; var c = [\"ms\", \"moz\", \"webkit\", \"o\"]; for (var a = 0; a < c.length && !window.requestAnimationFrame; ++a) { window.requestAnimationFrame = window[c[a] + \"RequestAnimationFrame\"]; window.cancelAnimationFrame = window[c[a] + \"CancelAnimationFrame\"] || window[c[a] + \"CancelRequestAnimationFrame\"]; } if (!window.requestAnimationFrame) { window.requestAnimationFrame = function (h, e) { var d = new Date().getTime(); var f = Math.max(0, 16 - (d - b)); var g = window.setTimeout(function () { h(d + f); }, f); b = d + f; return g; }; } if (!window.cancelAnimationFrame) { window.cancelAnimationFrame = function (d) { clearTimeout(d); }; } })(); /* * Point class */ var Point = (function () { function Point(x, y) { this.x = typeof x !== \"undefined\" ? x : 0; this.y = typeof y !== \"undefined\" ? y : 0; } Point.prototype.clone = function () { return new Point(this.x, this.y); }; Point.prototype.length = function (length) { if (typeof length == \"undefined\") return Math.sqrt(this.x * this.x + this.y * this.y); this.normalize(); this.x *= length; this.y *= length; return this; }; Point.prototype.normalize = function () { var length = this.length(); this.x /= length; this.y /= length; return this; }; return Point; })(); /* * Particle class */ var Particle = (function () { function Particle() { this.position = new Point(); this.velocity = new Point(); this.acceleration = new Point(); this.age = 0; } Particle.prototype.initialize = function (x, y, dx, dy) { this.position.x = x; this.position.y = y; this.velocity.x = dx; this.velocity.y = dy; this.acceleration.x = dx * settings.particles.effect; this.acceleration.y = dy * settings.particles.effect; this.age = 0; }; Particle.prototype.update = function (deltaTime) { this.position.x += this.velocity.x * deltaTime; this.position.y += this.velocity.y * deltaTime; this.velocity.x += this.acceleration.x * deltaTime; this.velocity.y += this.acceleration.y * deltaTime; this.age += deltaTime; }; Particle.prototype.draw = function (context, image) { function ease(t) { return --t * t * t + 1; } var size = image.width * ease(this.age / settings.particles.duration); context.globalAlpha = 1 - this.age / settings.particles.duration; context.drawImage( image, this.position.x - size / 2, this.position.y - size / 2, size, size ); }; return Particle; })(); /* * ParticlePool class */ var ParticlePool = (function () { var particles, firstActive = 0, firstFree = 0, duration = settings.particles.duration; function ParticlePool(length) { // create and populate particle pool particles = new Array(length); for (var i = 0; i < particles.length; i++) particles[i] = new Particle(); } ParticlePool.prototype.add = function (x, y, dx, dy) { particles[firstFree].initialize(x, y, dx, dy); // handle circular queue firstFree++; if (firstFree == particles.length) firstFree = 0; if (firstActive == firstFree) firstActive++; if (firstActive == particles.length) firstActive = 0; }; ParticlePool.prototype.update = function (deltaTime) { var i; // update active particles if (firstActive < firstFree) { for (i = firstActive; i < firstFree; i++) particles[i].update(deltaTime); } if (firstFree < firstActive) { for (i = firstActive; i < particles.length; i++) particles[i].update(deltaTime); for (i = 0; i < firstFree; i++) particles[i].update(deltaTime); } // remove inactive particles while ( particles[firstActive].age >= duration && firstActive != firstFree ) { firstActive++; if (firstActive == particles.length) firstActive = 0; } }; ParticlePool.prototype.draw = function (context, image) { // draw active particles if (firstActive < firstFree) { for (i = firstActive; i < firstFree; i++) particles[i].draw(context, image); } if (firstFree < firstActive) { for (i = firstActive; i < particles.length; i++) particles[i].draw(context, image); for (i = 0; i < firstFree; i++) particles[i].draw(context, image); } }; return ParticlePool; })(); /* * Putting it all together */ (function (canvas) { var context = canvas.getContext(\"2d\"), particles = new ParticlePool(settings.particles.length), particleRate = settings.particles.length / settings.particles.duration, // particles/sec time; // get point on heart with -PI"}],"posts":[{"title":"self introduction by Xu Hui","slug":"self introduction by Xu Hui","date":"2022-11-11T10:04:51.000Z","updated":"2022-11-11T03:42:14.392Z","comments":true,"path":"2022/11/11/self introduction by Xu Hui/","link":"","permalink":"http://iamsimate.github.io/2022/11/11/self%20introduction%20by%20Xu%20Hui/","excerpt":"","text":"","categories":[{"name":"阅读","slug":"阅读","permalink":"http://iamsimate.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"偏微分方程","slug":"偏微分方程","date":"2022-10-16T06:21:37.000Z","updated":"2022-10-16T06:24:05.098Z","comments":true,"path":"2022/10/16/偏微分方程/","link":"","permalink":"http://iamsimate.github.io/2022/10/16/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"阅读","slug":"阅读","permalink":"http://iamsimate.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"我的第一篇文章","slug":"我的第一篇文章","date":"2022-07-14T10:04:51.000Z","updated":"2022-11-17T10:39:35.725Z","comments":true,"path":"2022/07/14/我的第一篇文章/","link":"","permalink":"http://iamsimate.github.io/2022/07/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"前言大家好，今后将开始我的新学习之路，花费两天时间终于解决了基本问题，搭建好了简陋的博客，之后会将学习笔记陆续搬到网站上，公众号也会同步更新。 如何制作博客以及将博客部署到github上我基本上是在csdn上找的教程，其中一些文件的代码修改我并不太懂，回忆搭建过程也是坎坷零星，如果后面有时间，把我搭建过程中遇到的问题整理整理。以下是参考链接（全在我的主页收藏夹里了）:https://blog.csdn.net/m0_46488303?type=collect * { padding: 0; margin: 0; } html, body { height: 100%; padding: 0; margin: 0; background: #000; } .aa &#123; position: fixed; left: 50%; bottom: 10px; color: #ccc; &#125; .container &#123; width: 100%; height: 100%; &#125; canvas &#123; z-index: 99; position: absolute; width: 100%; height: 100%; &#125; /* * Settings */ var settings = { particles: { length: 500, // maximum amount of particles duration: 2, // particle duration in sec velocity: 100, // particle velocity in pixels/sec effect: -0.75, // play with this for a nice effect size: 30, // particle size in pixels }, }; (function () &#123; var b = 0; var c = [&quot;ms&quot;, &quot;moz&quot;, &quot;webkit&quot;, &quot;o&quot;]; for (var a = 0; a &lt; c.length &amp;&amp; !window.requestAnimationFrame; ++a) &#123; window.requestAnimationFrame = window[c[a] + &quot;RequestAnimationFrame&quot;]; window.cancelAnimationFrame = window[c[a] + &quot;CancelAnimationFrame&quot;] || window[c[a] + &quot;CancelRequestAnimationFrame&quot;]; &#125; if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function (h, e) &#123; var d = new Date().getTime(); var f = Math.max(0, 16 - (d - b)); var g = window.setTimeout(function () &#123; h(d + f); &#125;, f); b = d + f; return g; &#125;; &#125; if (!window.cancelAnimationFrame) &#123; window.cancelAnimationFrame = function (d) &#123; clearTimeout(d); &#125;; &#125; &#125;)(); /* * Point class */ var Point = (function () &#123; function Point(x, y) &#123; this.x = typeof x !== &quot;undefined&quot; ? x : 0; this.y = typeof y !== &quot;undefined&quot; ? y : 0; &#125; Point.prototype.clone = function () &#123; return new Point(this.x, this.y); &#125;; Point.prototype.length = function (length) &#123; if (typeof length == &quot;undefined&quot;) return Math.sqrt(this.x * this.x + this.y * this.y); this.normalize(); this.x *= length; this.y *= length; return this; &#125;; Point.prototype.normalize = function () &#123; var length = this.length(); this.x /= length; this.y /= length; return this; &#125;; return Point; &#125;)(); /* * Particle class */ var Particle = (function () &#123; function Particle() &#123; this.position = new Point(); this.velocity = new Point(); this.acceleration = new Point(); this.age = 0; &#125; Particle.prototype.initialize = function (x, y, dx, dy) &#123; this.position.x = x; this.position.y = y; this.velocity.x = dx; this.velocity.y = dy; this.acceleration.x = dx * settings.particles.effect; this.acceleration.y = dy * settings.particles.effect; this.age = 0; &#125;; Particle.prototype.update = function (deltaTime) &#123; this.position.x += this.velocity.x * deltaTime; this.position.y += this.velocity.y * deltaTime; this.velocity.x += this.acceleration.x * deltaTime; this.velocity.y += this.acceleration.y * deltaTime; this.age += deltaTime; &#125;; Particle.prototype.draw = function (context, image) &#123; function ease(t) &#123; return --t * t * t + 1; &#125; var size = image.width * ease(this.age / settings.particles.duration); context.globalAlpha = 1 - this.age / settings.particles.duration; context.drawImage( image, this.position.x - size / 2, this.position.y - size / 2, size, size ); &#125;; return Particle; &#125;)(); /* * ParticlePool class */ var ParticlePool = (function () &#123; var particles, firstActive = 0, firstFree = 0, duration = settings.particles.duration; function ParticlePool(length) &#123; // create and populate particle pool particles = new Array(length); for (var i = 0; i &lt; particles.length; i++) particles[i] = new Particle(); &#125; ParticlePool.prototype.add = function (x, y, dx, dy) &#123; particles[firstFree].initialize(x, y, dx, dy); // handle circular queue firstFree++; if (firstFree == particles.length) firstFree = 0; if (firstActive == firstFree) firstActive++; if (firstActive == particles.length) firstActive = 0; &#125;; ParticlePool.prototype.update = function (deltaTime) &#123; var i; // update active particles if (firstActive &lt; firstFree) &#123; for (i = firstActive; i &lt; firstFree; i++) particles[i].update(deltaTime); &#125; if (firstFree &lt; firstActive) &#123; for (i = firstActive; i &lt; particles.length; i++) particles[i].update(deltaTime); for (i = 0; i &lt; firstFree; i++) particles[i].update(deltaTime); &#125; // remove inactive particles while ( particles[firstActive].age &gt;= duration &amp;&amp; firstActive != firstFree ) &#123; firstActive++; if (firstActive == particles.length) firstActive = 0; &#125; &#125;; ParticlePool.prototype.draw = function (context, image) &#123; // draw active particles if (firstActive &lt; firstFree) &#123; for (i = firstActive; i &lt; firstFree; i++) particles[i].draw(context, image); &#125; if (firstFree &lt; firstActive) &#123; for (i = firstActive; i &lt; particles.length; i++) particles[i].draw(context, image); for (i = 0; i &lt; firstFree; i++) particles[i].draw(context, image); &#125; &#125;; return ParticlePool; &#125;)(); /* * Putting it all together */ (function (canvas) &#123; var context = canvas.getContext(&quot;2d&quot;), particles = new ParticlePool(settings.particles.length), particleRate = settings.particles.length / settings.particles.duration, // particles/sec time; // get point on heart with -PI &lt;= t &lt;= PI function pointOnHeart(t) &#123; return new Point( 160 * Math.pow(Math.sin(t), 3), 130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25 ); &#125; // creating the particle image using a dummy canvas var image = (function () &#123; var canvas = document.createElement(&quot;canvas&quot;), context = canvas.getContext(&quot;2d&quot;); canvas.width = settings.particles.size; canvas.height = settings.particles.size; // helper function to create the path function to(t) &#123; var point = pointOnHeart(t); point.x = settings.particles.size / 2 + (point.x * settings.particles.size) / 350; point.y = settings.particles.size / 2 - (point.y * settings.particles.size) / 350; return point; &#125; // create the path context.beginPath(); var t = -Math.PI; var point = to(t); context.moveTo(point.x, point.y); while (t &lt; Math.PI) &#123; t += 0.01; // baby steps! point = to(t); context.lineTo(point.x, point.y); &#125; context.closePath(); // create the fill context.fillStyle = &quot;#ea80b0&quot;; context.fill(); // create the image var image = new Image(); image.src = canvas.toDataURL(); return image; &#125;)(); // render that thing! function render() &#123; // next animation frame requestAnimationFrame(render); // update time var newTime = new Date().getTime() / 1000, deltaTime = newTime - (time || newTime); time = newTime; // clear canvas context.clearRect(0, 0, canvas.width, canvas.height); // create new particles var amount = particleRate * deltaTime; for (var i = 0; i &lt; amount; i++) &#123; var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random()); var dir = pos.clone().length(settings.particles.velocity); particles.add( canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y ); &#125; // update and draw particles particles.update(deltaTime); particles.draw(context, image); &#125; // handle (re-)sizing of the canvas function onResize() &#123; canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; &#125; window.onresize = onResize; // delay rendering bootstrap setTimeout(function () &#123; onResize(); render(); &#125;, 10); &#125;)(document.getElementById(&quot;pinkboard&quot;)); var RENDERER = { INIT_CHERRY_BLOSSOM_COUNT: 30, MAX_ADDING_INTERVAL: 10, init: function () { this.setParameters(); this.reconstructMethods(); this.createCherries(); this.render(); if ( navigator.userAgent.match( /(phone|pod|iPhone|iPod|ios|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i ) ) { // var box = document.querySelectorAll(\".box\")[0]; // console.log(box, \"移动端\"); // box.style.marginTop = \"65%\"; } }, setParameters: function () { this.$container = $(\"#jsi-cherry-container\"); this.width = this.$container.width(); this.height = this.$container.height(); this.context = $(\"\") .attr({ width: this.width, height: this.height }) .appendTo(this.$container) .get(0) var rate = this.FOCUS_POSITION / (this.z + this.FOCUS_POSITION), x = this.renderer.width / 2 + this.x * rate, y = this.renderer.height / 2 - this.y * rate; return { rate: rate, x: x, y: y }; }, re } } else { this.phi += Math.PI / (axis.y == this.thresholdY ? 200 : 500); this.phi %= Math.PI; } if (this.y -this.FOCUS_POSITION && this.z < this.FAR_LIMIT && this.x < this.renderer.width * 1.5 ); }, }; $(function () { RENDERER.init(); });","categories":[{"name":"技术","slug":"技术","permalink":"http://iamsimate.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"泛函分析","slug":"泛函分析","date":"2022-07-14T10:04:51.000Z","updated":"2022-10-03T08:33:23.039Z","comments":true,"path":"2022/07/14/泛函分析/","link":"","permalink":"http://iamsimate.github.io/2022/07/14/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[{"name":"阅读","slug":"阅读","permalink":"http://iamsimate.github.io/categories/%E9%98%85%E8%AF%BB/"}],"tags":[]}],"categories":[{"name":"阅读","slug":"阅读","permalink":"http://iamsimate.github.io/categories/%E9%98%85%E8%AF%BB/"},{"name":"技术","slug":"技术","permalink":"http://iamsimate.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]}